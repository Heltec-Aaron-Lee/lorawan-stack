// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: lorawan-stack/api/messages.proto

package api

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/golang/protobuf/ptypes"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = ptypes.DynamicAny{}
)

// define the regex for a UUID once up-front
var _messages_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on UplinkMessage with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *UplinkMessage) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for RawPayload

	if v, ok := interface{}(m.GetPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UplinkMessageValidationError{
				field:  "Payload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSettings() == nil {
		return UplinkMessageValidationError{
			field:  "Settings",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UplinkMessageValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRxMetadata() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UplinkMessageValidationError{
					field:  fmt.Sprintf("RxMetadata[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if v, ok := interface{}(m.GetReceivedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UplinkMessageValidationError{
				field:  "ReceivedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCorrelationIds() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) > 100 {
			return UplinkMessageValidationError{
				field:  fmt.Sprintf("CorrelationIds[%v]", idx),
				reason: "value length must be at most 100 runes",
			}
		}

	}

	if m.GetDeviceChannelIndex() > 255 {
		return UplinkMessageValidationError{
			field:  "DeviceChannelIndex",
			reason: "value must be less than or equal to 255",
		}
	}

	if v, ok := interface{}(m.GetConsumedAirtime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UplinkMessageValidationError{
				field:  "ConsumedAirtime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// UplinkMessageValidationError is the validation error returned by
// UplinkMessage.Validate if the designated constraints aren't met.
type UplinkMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UplinkMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UplinkMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UplinkMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UplinkMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UplinkMessageValidationError) ErrorName() string { return "UplinkMessageValidationError" }

// Error satisfies the builtin error interface
func (e UplinkMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUplinkMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UplinkMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UplinkMessageValidationError{}

// Validate checks the field values on DownlinkMessage with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *DownlinkMessage) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for RawPayload

	if v, ok := interface{}(m.GetPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DownlinkMessageValidationError{
				field:  "Payload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetEndDeviceIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DownlinkMessageValidationError{
				field:  "EndDeviceIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCorrelationIds() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) > 100 {
			return DownlinkMessageValidationError{
				field:  fmt.Sprintf("CorrelationIds[%v]", idx),
				reason: "value length must be at most 100 runes",
			}
		}

	}

	switch m.Settings.(type) {

	case *DownlinkMessage_Request:

		if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownlinkMessageValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DownlinkMessage_Scheduled:

		if v, ok := interface{}(m.GetScheduled()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownlinkMessageValidationError{
					field:  "Scheduled",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		return DownlinkMessageValidationError{
			field:  "Settings",
			reason: "value is required",
		}

	}

	return nil
}

// DownlinkMessageValidationError is the validation error returned by
// DownlinkMessage.Validate if the designated constraints aren't met.
type DownlinkMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownlinkMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownlinkMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownlinkMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownlinkMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownlinkMessageValidationError) ErrorName() string { return "DownlinkMessageValidationError" }

// Error satisfies the builtin error interface
func (e DownlinkMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownlinkMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownlinkMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownlinkMessageValidationError{}

// Validate checks the field values on TxAcknowledgment with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *TxAcknowledgment) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetCorrelationIds() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) > 100 {
			return TxAcknowledgmentValidationError{
				field:  fmt.Sprintf("CorrelationIds[%v]", idx),
				reason: "value length must be at most 100 runes",
			}
		}

	}

	if _, ok := TxAcknowledgment_Result_name[int32(m.GetResult())]; !ok {
		return TxAcknowledgmentValidationError{
			field:  "Result",
			reason: "value must be one of the defined enum values",
		}
	}

	return nil
}

// TxAcknowledgmentValidationError is the validation error returned by
// TxAcknowledgment.Validate if the designated constraints aren't met.
type TxAcknowledgmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxAcknowledgmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxAcknowledgmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxAcknowledgmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxAcknowledgmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxAcknowledgmentValidationError) ErrorName() string { return "TxAcknowledgmentValidationError" }

// Error satisfies the builtin error interface
func (e TxAcknowledgmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxAcknowledgment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxAcknowledgmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxAcknowledgmentValidationError{}

// Validate checks the field values on GatewayUplinkMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GatewayUplinkMessage) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetMessage() == nil {
		return GatewayUplinkMessageValidationError{
			field:  "Message",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GatewayUplinkMessageValidationError{
				field:  "Message",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BandId

	return nil
}

// GatewayUplinkMessageValidationError is the validation error returned by
// GatewayUplinkMessage.Validate if the designated constraints aren't met.
type GatewayUplinkMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GatewayUplinkMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GatewayUplinkMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GatewayUplinkMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GatewayUplinkMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GatewayUplinkMessageValidationError) ErrorName() string {
	return "GatewayUplinkMessageValidationError"
}

// Error satisfies the builtin error interface
func (e GatewayUplinkMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGatewayUplinkMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GatewayUplinkMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GatewayUplinkMessageValidationError{}

// Validate checks the field values on ApplicationUplink with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *ApplicationUplink) Validate() error {
	if m == nil {
		return nil
	}

	if len(m.GetSessionKeyId()) > 2048 {
		return ApplicationUplinkValidationError{
			field:  "SessionKeyId",
			reason: "value length must be at most 2048 bytes",
		}
	}

	if val := m.GetFPort(); val < 1 || val > 255 {
		return ApplicationUplinkValidationError{
			field:  "FPort",
			reason: "value must be inside range [1, 255]",
		}
	}

	if _, ok := _ApplicationUplink_FPort_NotInLookup[m.GetFPort()]; ok {
		return ApplicationUplinkValidationError{
			field:  "FPort",
			reason: "value must not be in list [224]",
		}
	}

	// no validation rules for FCnt

	// no validation rules for FrmPayload

	if v, ok := interface{}(m.GetDecodedPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationUplinkValidationError{
				field:  "DecodedPayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetRxMetadata()) < 1 {
		return ApplicationUplinkValidationError{
			field:  "RxMetadata",
			reason: "value must contain at least 1 item(s)",
		}
	}

	for idx, item := range m.GetRxMetadata() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUplinkValidationError{
					field:  fmt.Sprintf("RxMetadata[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetSettings() == nil {
		return ApplicationUplinkValidationError{
			field:  "Settings",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationUplinkValidationError{
				field:  "Settings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetReceivedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationUplinkValidationError{
				field:  "ReceivedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetAppSKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationUplinkValidationError{
				field:  "AppSKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LastAFCntDown

	// no validation rules for Confirmed

	if v, ok := interface{}(m.GetConsumedAirtime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationUplinkValidationError{
				field:  "ConsumedAirtime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for key, val := range m.GetLocations() {
		_ = val

		// no validation rules for Locations[key]

		if v, ok := interface{}(val).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUplinkValidationError{
					field:  fmt.Sprintf("Locations[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// ApplicationUplinkValidationError is the validation error returned by
// ApplicationUplink.Validate if the designated constraints aren't met.
type ApplicationUplinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationUplinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationUplinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationUplinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationUplinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationUplinkValidationError) ErrorName() string {
	return "ApplicationUplinkValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationUplinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationUplink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationUplinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationUplinkValidationError{}

var _ApplicationUplink_FPort_NotInLookup = map[uint32]struct{}{
	224: {},
}

// Validate checks the field values on ApplicationLocation with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ApplicationLocation) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Service

	if m.GetLocation() == nil {
		return ApplicationLocationValidationError{
			field:  "Location",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationLocationValidationError{
				field:  "Location",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for key, val := range m.GetAttributes() {
		_ = val

		if utf8.RuneCountInString(key) > 36 {
			return ApplicationLocationValidationError{
				field:  fmt.Sprintf("Attributes[%v]", key),
				reason: "value length must be at most 36 runes",
			}
		}

		if !_ApplicationLocation_Attributes_Pattern.MatchString(key) {
			return ApplicationLocationValidationError{
				field:  fmt.Sprintf("Attributes[%v]", key),
				reason: "value does not match regex pattern \"^[a-z0-9](?:[-]?[a-z0-9]){2,}$\"",
			}
		}

		// no validation rules for Attributes[key]
	}

	return nil
}

// ApplicationLocationValidationError is the validation error returned by
// ApplicationLocation.Validate if the designated constraints aren't met.
type ApplicationLocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationLocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationLocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationLocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationLocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationLocationValidationError) ErrorName() string {
	return "ApplicationLocationValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationLocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationLocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationLocationValidationError{}

var _ApplicationLocation_Attributes_Pattern = regexp.MustCompile("^[a-z0-9](?:[-]?[a-z0-9]){2,}$")

// Validate checks the field values on ApplicationJoinAccept with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ApplicationJoinAccept) Validate() error {
	if m == nil {
		return nil
	}

	if len(m.GetSessionKeyId()) > 2048 {
		return ApplicationJoinAcceptValidationError{
			field:  "SessionKeyId",
			reason: "value length must be at most 2048 bytes",
		}
	}

	if v, ok := interface{}(m.GetAppSKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationJoinAcceptValidationError{
				field:  "AppSKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInvalidatedDownlinks() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationJoinAcceptValidationError{
					field:  fmt.Sprintf("InvalidatedDownlinks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PendingSession

	if v, ok := interface{}(m.GetReceivedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationJoinAcceptValidationError{
				field:  "ReceivedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// ApplicationJoinAcceptValidationError is the validation error returned by
// ApplicationJoinAccept.Validate if the designated constraints aren't met.
type ApplicationJoinAcceptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationJoinAcceptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationJoinAcceptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationJoinAcceptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationJoinAcceptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationJoinAcceptValidationError) ErrorName() string {
	return "ApplicationJoinAcceptValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationJoinAcceptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationJoinAccept.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationJoinAcceptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationJoinAcceptValidationError{}

// Validate checks the field values on ApplicationDownlink with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ApplicationDownlink) Validate() error {
	if m == nil {
		return nil
	}

	if len(m.GetSessionKeyId()) > 2048 {
		return ApplicationDownlinkValidationError{
			field:  "SessionKeyId",
			reason: "value length must be at most 2048 bytes",
		}
	}

	if val := m.GetFPort(); val < 1 || val > 255 {
		return ApplicationDownlinkValidationError{
			field:  "FPort",
			reason: "value must be inside range [1, 255]",
		}
	}

	if _, ok := _ApplicationDownlink_FPort_NotInLookup[m.GetFPort()]; ok {
		return ApplicationDownlinkValidationError{
			field:  "FPort",
			reason: "value must not be in list [224]",
		}
	}

	// no validation rules for FCnt

	// no validation rules for FrmPayload

	if v, ok := interface{}(m.GetDecodedPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationDownlinkValidationError{
				field:  "DecodedPayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Confirmed

	if v, ok := interface{}(m.GetClassBC()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationDownlinkValidationError{
				field:  "ClassBC",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := TxSchedulePriority_name[int32(m.GetPriority())]; !ok {
		return ApplicationDownlinkValidationError{
			field:  "Priority",
			reason: "value must be one of the defined enum values",
		}
	}

	for idx, item := range m.GetCorrelationIds() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) > 100 {
			return ApplicationDownlinkValidationError{
				field:  fmt.Sprintf("CorrelationIds[%v]", idx),
				reason: "value length must be at most 100 runes",
			}
		}

	}

	return nil
}

// ApplicationDownlinkValidationError is the validation error returned by
// ApplicationDownlink.Validate if the designated constraints aren't met.
type ApplicationDownlinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationDownlinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationDownlinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationDownlinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationDownlinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationDownlinkValidationError) ErrorName() string {
	return "ApplicationDownlinkValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationDownlinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationDownlink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationDownlinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationDownlinkValidationError{}

var _ApplicationDownlink_FPort_NotInLookup = map[uint32]struct{}{
	224: {},
}

// Validate checks the field values on ApplicationDownlinks with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ApplicationDownlinks) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetDownlinks() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationDownlinksValidationError{
					field:  fmt.Sprintf("Downlinks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// ApplicationDownlinksValidationError is the validation error returned by
// ApplicationDownlinks.Validate if the designated constraints aren't met.
type ApplicationDownlinksValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationDownlinksValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationDownlinksValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationDownlinksValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationDownlinksValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationDownlinksValidationError) ErrorName() string {
	return "ApplicationDownlinksValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationDownlinksValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationDownlinks.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationDownlinksValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationDownlinksValidationError{}

// Validate checks the field values on ApplicationDownlinkFailed with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ApplicationDownlinkFailed) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetDownlink() == nil {
		return ApplicationDownlinkFailedValidationError{
			field:  "Downlink",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetDownlink()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationDownlinkFailedValidationError{
				field:  "Downlink",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetError() == nil {
		return ApplicationDownlinkFailedValidationError{
			field:  "Error",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationDownlinkFailedValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// ApplicationDownlinkFailedValidationError is the validation error returned by
// ApplicationDownlinkFailed.Validate if the designated constraints aren't met.
type ApplicationDownlinkFailedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationDownlinkFailedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationDownlinkFailedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationDownlinkFailedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationDownlinkFailedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationDownlinkFailedValidationError) ErrorName() string {
	return "ApplicationDownlinkFailedValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationDownlinkFailedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationDownlinkFailed.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationDownlinkFailedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationDownlinkFailedValidationError{}

// Validate checks the field values on ApplicationInvalidatedDownlinks with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ApplicationInvalidatedDownlinks) Validate() error {
	if m == nil {
		return nil
	}

	if len(m.GetDownlinks()) < 1 {
		return ApplicationInvalidatedDownlinksValidationError{
			field:  "Downlinks",
			reason: "value must contain at least 1 item(s)",
		}
	}

	for idx, item := range m.GetDownlinks() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationInvalidatedDownlinksValidationError{
					field:  fmt.Sprintf("Downlinks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for LastFCntDown

	return nil
}

// ApplicationInvalidatedDownlinksValidationError is the validation error
// returned by ApplicationInvalidatedDownlinks.Validate if the designated
// constraints aren't met.
type ApplicationInvalidatedDownlinksValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationInvalidatedDownlinksValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationInvalidatedDownlinksValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationInvalidatedDownlinksValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationInvalidatedDownlinksValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationInvalidatedDownlinksValidationError) ErrorName() string {
	return "ApplicationInvalidatedDownlinksValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationInvalidatedDownlinksValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationInvalidatedDownlinks.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationInvalidatedDownlinksValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationInvalidatedDownlinksValidationError{}

// Validate checks the field values on ApplicationServiceData with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ApplicationServiceData) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Service

	if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationServiceDataValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// ApplicationServiceDataValidationError is the validation error returned by
// ApplicationServiceData.Validate if the designated constraints aren't met.
type ApplicationServiceDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationServiceDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationServiceDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationServiceDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationServiceDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationServiceDataValidationError) ErrorName() string {
	return "ApplicationServiceDataValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationServiceDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationServiceData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationServiceDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationServiceDataValidationError{}

// Validate checks the field values on ApplicationUp with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *ApplicationUp) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetEndDeviceIds() == nil {
		return ApplicationUpValidationError{
			field:  "EndDeviceIds",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetEndDeviceIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationUpValidationError{
				field:  "EndDeviceIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCorrelationIds() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) > 100 {
			return ApplicationUpValidationError{
				field:  fmt.Sprintf("CorrelationIds[%v]", idx),
				reason: "value length must be at most 100 runes",
			}
		}

	}

	if v, ok := interface{}(m.GetReceivedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationUpValidationError{
				field:  "ReceivedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Simulated

	switch m.Up.(type) {

	case *ApplicationUp_UplinkMessage:

		if v, ok := interface{}(m.GetUplinkMessage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUpValidationError{
					field:  "UplinkMessage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApplicationUp_JoinAccept:

		if v, ok := interface{}(m.GetJoinAccept()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUpValidationError{
					field:  "JoinAccept",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApplicationUp_DownlinkAck:

		if v, ok := interface{}(m.GetDownlinkAck()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUpValidationError{
					field:  "DownlinkAck",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApplicationUp_DownlinkNack:

		if v, ok := interface{}(m.GetDownlinkNack()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUpValidationError{
					field:  "DownlinkNack",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApplicationUp_DownlinkSent:

		if v, ok := interface{}(m.GetDownlinkSent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUpValidationError{
					field:  "DownlinkSent",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApplicationUp_DownlinkFailed:

		if v, ok := interface{}(m.GetDownlinkFailed()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUpValidationError{
					field:  "DownlinkFailed",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApplicationUp_DownlinkQueued:

		if v, ok := interface{}(m.GetDownlinkQueued()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUpValidationError{
					field:  "DownlinkQueued",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApplicationUp_DownlinkQueueInvalidated:

		if v, ok := interface{}(m.GetDownlinkQueueInvalidated()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUpValidationError{
					field:  "DownlinkQueueInvalidated",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApplicationUp_LocationSolved:

		if v, ok := interface{}(m.GetLocationSolved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUpValidationError{
					field:  "LocationSolved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ApplicationUp_ServiceData:

		if v, ok := interface{}(m.GetServiceData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationUpValidationError{
					field:  "ServiceData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		return ApplicationUpValidationError{
			field:  "Up",
			reason: "value is required",
		}

	}

	return nil
}

// ApplicationUpValidationError is the validation error returned by
// ApplicationUp.Validate if the designated constraints aren't met.
type ApplicationUpValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationUpValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationUpValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationUpValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationUpValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationUpValidationError) ErrorName() string { return "ApplicationUpValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationUpValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationUp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationUpValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationUpValidationError{}

// Validate checks the field values on MessagePayloadFormatters with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *MessagePayloadFormatters) Validate() error {
	if m == nil {
		return nil
	}

	if _, ok := PayloadFormatter_name[int32(m.GetUpFormatter())]; !ok {
		return MessagePayloadFormattersValidationError{
			field:  "UpFormatter",
			reason: "value must be one of the defined enum values",
		}
	}

	// no validation rules for UpFormatterParameter

	if _, ok := PayloadFormatter_name[int32(m.GetDownFormatter())]; !ok {
		return MessagePayloadFormattersValidationError{
			field:  "DownFormatter",
			reason: "value must be one of the defined enum values",
		}
	}

	// no validation rules for DownFormatterParameter

	return nil
}

// MessagePayloadFormattersValidationError is the validation error returned by
// MessagePayloadFormatters.Validate if the designated constraints aren't met.
type MessagePayloadFormattersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessagePayloadFormattersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessagePayloadFormattersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessagePayloadFormattersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessagePayloadFormattersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessagePayloadFormattersValidationError) ErrorName() string {
	return "MessagePayloadFormattersValidationError"
}

// Error satisfies the builtin error interface
func (e MessagePayloadFormattersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessagePayloadFormatters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessagePayloadFormattersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessagePayloadFormattersValidationError{}

// Validate checks the field values on DownlinkQueueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *DownlinkQueueRequest) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetEndDeviceIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DownlinkQueueRequestValidationError{
				field:  "EndDeviceIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetDownlinks()) > 100000 {
		return DownlinkQueueRequestValidationError{
			field:  "Downlinks",
			reason: "value must contain no more than 100000 item(s)",
		}
	}

	for idx, item := range m.GetDownlinks() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownlinkQueueRequestValidationError{
					field:  fmt.Sprintf("Downlinks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// DownlinkQueueRequestValidationError is the validation error returned by
// DownlinkQueueRequest.Validate if the designated constraints aren't met.
type DownlinkQueueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownlinkQueueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownlinkQueueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownlinkQueueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownlinkQueueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownlinkQueueRequestValidationError) ErrorName() string {
	return "DownlinkQueueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DownlinkQueueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownlinkQueueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownlinkQueueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownlinkQueueRequestValidationError{}

// Validate checks the field values on ApplicationDownlink_ClassBC with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ApplicationDownlink_ClassBC) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetGateways() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationDownlink_ClassBCValidationError{
					field:  fmt.Sprintf("Gateways[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if v, ok := interface{}(m.GetAbsoluteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationDownlink_ClassBCValidationError{
				field:  "AbsoluteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// ApplicationDownlink_ClassBCValidationError is the validation error returned
// by ApplicationDownlink_ClassBC.Validate if the designated constraints
// aren't met.
type ApplicationDownlink_ClassBCValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationDownlink_ClassBCValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationDownlink_ClassBCValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationDownlink_ClassBCValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationDownlink_ClassBCValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationDownlink_ClassBCValidationError) ErrorName() string {
	return "ApplicationDownlink_ClassBCValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationDownlink_ClassBCValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationDownlink_ClassBC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationDownlink_ClassBCValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationDownlink_ClassBCValidationError{}
