// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: lorawan-stack/api/user.proto

package api

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/golang/protobuf/ptypes"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = ptypes.DynamicAny{}
)

// define the regex for a UUID once up-front
var _user_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *User) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetIds() == nil {
		return UserValidationError{
			field:  "Ids",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "Ids",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetName()) > 50 {
		return UserValidationError{
			field:  "Name",
			reason: "value length must be at most 50 runes",
		}
	}

	if utf8.RuneCountInString(m.GetDescription()) > 2000 {
		return UserValidationError{
			field:  "Description",
			reason: "value length must be at most 2000 runes",
		}
	}

	for key, val := range m.GetAttributes() {
		_ = val

		if utf8.RuneCountInString(key) > 36 {
			return UserValidationError{
				field:  fmt.Sprintf("Attributes[%v]", key),
				reason: "value length must be at most 36 runes",
			}
		}

		if !_User_Attributes_Pattern.MatchString(key) {
			return UserValidationError{
				field:  fmt.Sprintf("Attributes[%v]", key),
				reason: "value does not match regex pattern \"^[a-z0-9](?:[-]?[a-z0-9]){2,}$\"",
			}
		}

		// no validation rules for Attributes[key]
	}

	for idx, item := range m.GetContactInfo() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserValidationError{
					field:  fmt.Sprintf("ContactInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if err := m._validateEmail(m.GetPrimaryEmailAddress()); err != nil {
		return UserValidationError{
			field:  "PrimaryEmailAddress",
			reason: "value must be a valid email address",
			cause:  err,
		}
	}

	if v, ok := interface{}(m.GetPrimaryEmailAddressValidatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "PrimaryEmailAddressValidatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Password

	if v, ok := interface{}(m.GetPasswordUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "PasswordUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RequirePasswordUpdate

	if _, ok := State_name[int32(m.GetState())]; !ok {
		return UserValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
	}

	// no validation rules for Admin

	// no validation rules for TemporaryPassword

	if v, ok := interface{}(m.GetTemporaryPasswordCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "TemporaryPasswordCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetTemporaryPasswordExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "TemporaryPasswordExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetProfilePicture()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "ProfilePicture",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

func (m *User) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *User) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

var _User_Attributes_Pattern = regexp.MustCompile("^[a-z0-9](?:[-]?[a-z0-9]){2,}$")

// Validate checks the field values on Users with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Users) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UsersValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// UsersValidationError is the validation error returned by Users.Validate if
// the designated constraints aren't met.
type UsersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UsersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UsersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UsersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UsersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UsersValidationError) ErrorName() string { return "UsersValidationError" }

// Error satisfies the builtin error interface
func (e UsersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUsers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UsersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UsersValidationError{}

// Validate checks the field values on GetUserRequest with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *GetUserRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUserIds() == nil {
		return GetUserRequestValidationError{
			field:  "UserIds",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUserIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserRequestValidationError{
				field:  "UserIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetFieldMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserRequestValidationError{
				field:  "FieldMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// GetUserRequestValidationError is the validation error returned by
// GetUserRequest.Validate if the designated constraints aren't met.
type GetUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserRequestValidationError) ErrorName() string { return "GetUserRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserRequestValidationError{}

// Validate checks the field values on ListUsersRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *ListUsersRequest) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetFieldMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUsersRequestValidationError{
				field:  "FieldMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _ListUsersRequest_Order_InLookup[m.GetOrder()]; !ok {
		return ListUsersRequestValidationError{
			field:  "Order",
			reason: "value must be in list [ user_id -user_id name -name primary_email_address -primary_email_address state -state admin -admin created_at -created_at]",
		}
	}

	if m.GetLimit() > 1000 {
		return ListUsersRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 1000",
		}
	}

	// no validation rules for Page

	return nil
}

// ListUsersRequestValidationError is the validation error returned by
// ListUsersRequest.Validate if the designated constraints aren't met.
type ListUsersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUsersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUsersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUsersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUsersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUsersRequestValidationError) ErrorName() string { return "ListUsersRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListUsersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUsersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUsersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUsersRequestValidationError{}

var _ListUsersRequest_Order_InLookup = map[string]struct{}{
	"":                       {},
	"user_id":                {},
	"-user_id":               {},
	"name":                   {},
	"-name":                  {},
	"primary_email_address":  {},
	"-primary_email_address": {},
	"state":                  {},
	"-state":                 {},
	"admin":                  {},
	"-admin":                 {},
	"created_at":             {},
	"-created_at":            {},
}

// Validate checks the field values on CreateUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *CreateUserRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUser() == nil {
		return CreateUserRequestValidationError{
			field:  "User",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserRequestValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InvitationToken

	return nil
}

// CreateUserRequestValidationError is the validation error returned by
// CreateUserRequest.Validate if the designated constraints aren't met.
type CreateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserRequestValidationError) ErrorName() string {
	return "CreateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserRequestValidationError{}

// Validate checks the field values on UpdateUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *UpdateUserRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUser() == nil {
		return UpdateUserRequestValidationError{
			field:  "User",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserRequestValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetFieldMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserRequestValidationError{
				field:  "FieldMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// UpdateUserRequestValidationError is the validation error returned by
// UpdateUserRequest.Validate if the designated constraints aren't met.
type UpdateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserRequestValidationError) ErrorName() string {
	return "UpdateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserRequestValidationError{}

// Validate checks the field values on CreateTemporaryPasswordRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *CreateTemporaryPasswordRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUserIds() == nil {
		return CreateTemporaryPasswordRequestValidationError{
			field:  "UserIds",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUserIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTemporaryPasswordRequestValidationError{
				field:  "UserIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// CreateTemporaryPasswordRequestValidationError is the validation error
// returned by CreateTemporaryPasswordRequest.Validate if the designated
// constraints aren't met.
type CreateTemporaryPasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTemporaryPasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTemporaryPasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTemporaryPasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTemporaryPasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTemporaryPasswordRequestValidationError) ErrorName() string {
	return "CreateTemporaryPasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTemporaryPasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTemporaryPasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTemporaryPasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTemporaryPasswordRequestValidationError{}

// Validate checks the field values on UpdateUserPasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *UpdateUserPasswordRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUserIds() == nil {
		return UpdateUserPasswordRequestValidationError{
			field:  "UserIds",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUserIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserPasswordRequestValidationError{
				field:  "UserIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for New

	// no validation rules for Old

	// no validation rules for RevokeAllAccess

	return nil
}

// UpdateUserPasswordRequestValidationError is the validation error returned by
// UpdateUserPasswordRequest.Validate if the designated constraints aren't met.
type UpdateUserPasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserPasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserPasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserPasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserPasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserPasswordRequestValidationError) ErrorName() string {
	return "UpdateUserPasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserPasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserPasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserPasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserPasswordRequestValidationError{}

// Validate checks the field values on ListUserAPIKeysRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ListUserAPIKeysRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUserIds() == nil {
		return ListUserAPIKeysRequestValidationError{
			field:  "UserIds",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUserIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUserAPIKeysRequestValidationError{
				field:  "UserIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetLimit() > 1000 {
		return ListUserAPIKeysRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 1000",
		}
	}

	// no validation rules for Page

	return nil
}

// ListUserAPIKeysRequestValidationError is the validation error returned by
// ListUserAPIKeysRequest.Validate if the designated constraints aren't met.
type ListUserAPIKeysRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserAPIKeysRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserAPIKeysRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserAPIKeysRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserAPIKeysRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserAPIKeysRequestValidationError) ErrorName() string {
	return "ListUserAPIKeysRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserAPIKeysRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserAPIKeysRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserAPIKeysRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserAPIKeysRequestValidationError{}

// Validate checks the field values on GetUserAPIKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetUserAPIKeyRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUserIds() == nil {
		return GetUserAPIKeyRequestValidationError{
			field:  "UserIds",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUserIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserAPIKeyRequestValidationError{
				field:  "UserIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for KeyId

	return nil
}

// GetUserAPIKeyRequestValidationError is the validation error returned by
// GetUserAPIKeyRequest.Validate if the designated constraints aren't met.
type GetUserAPIKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserAPIKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserAPIKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserAPIKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserAPIKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserAPIKeyRequestValidationError) ErrorName() string {
	return "GetUserAPIKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserAPIKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserAPIKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserAPIKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserAPIKeyRequestValidationError{}

// Validate checks the field values on CreateUserAPIKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *CreateUserAPIKeyRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUserIds() == nil {
		return CreateUserAPIKeyRequestValidationError{
			field:  "UserIds",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUserIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserAPIKeyRequestValidationError{
				field:  "UserIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetName()) > 50 {
		return CreateUserAPIKeyRequestValidationError{
			field:  "Name",
			reason: "value length must be at most 50 runes",
		}
	}

	for idx, item := range m.GetRights() {
		_, _ = idx, item

		if _, ok := Right_name[int32(item)]; !ok {
			return CreateUserAPIKeyRequestValidationError{
				field:  fmt.Sprintf("Rights[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
		}

	}

	return nil
}

// CreateUserAPIKeyRequestValidationError is the validation error returned by
// CreateUserAPIKeyRequest.Validate if the designated constraints aren't met.
type CreateUserAPIKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserAPIKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserAPIKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserAPIKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserAPIKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserAPIKeyRequestValidationError) ErrorName() string {
	return "CreateUserAPIKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserAPIKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserAPIKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserAPIKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserAPIKeyRequestValidationError{}

// Validate checks the field values on UpdateUserAPIKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *UpdateUserAPIKeyRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUserIds() == nil {
		return UpdateUserAPIKeyRequestValidationError{
			field:  "UserIds",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUserIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserAPIKeyRequestValidationError{
				field:  "UserIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetApiKey() == nil {
		return UpdateUserAPIKeyRequestValidationError{
			field:  "ApiKey",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetApiKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserAPIKeyRequestValidationError{
				field:  "ApiKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// UpdateUserAPIKeyRequestValidationError is the validation error returned by
// UpdateUserAPIKeyRequest.Validate if the designated constraints aren't met.
type UpdateUserAPIKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserAPIKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserAPIKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserAPIKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserAPIKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserAPIKeyRequestValidationError) ErrorName() string {
	return "UpdateUserAPIKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserAPIKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserAPIKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserAPIKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserAPIKeyRequestValidationError{}

// Validate checks the field values on Invitation with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Invitation) Validate() error {
	if m == nil {
		return nil
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		return InvitationValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
	}

	// no validation rules for Token

	if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvitationValidationError{
				field:  "ExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvitationValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvitationValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetAcceptedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvitationValidationError{
				field:  "AcceptedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetAcceptedBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvitationValidationError{
				field:  "AcceptedBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

func (m *Invitation) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *Invitation) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// InvitationValidationError is the validation error returned by
// Invitation.Validate if the designated constraints aren't met.
type InvitationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvitationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvitationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvitationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvitationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvitationValidationError) ErrorName() string { return "InvitationValidationError" }

// Error satisfies the builtin error interface
func (e InvitationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvitation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvitationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvitationValidationError{}

// Validate checks the field values on ListInvitationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ListInvitationsRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetLimit() > 1000 {
		return ListInvitationsRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 1000",
		}
	}

	// no validation rules for Page

	return nil
}

// ListInvitationsRequestValidationError is the validation error returned by
// ListInvitationsRequest.Validate if the designated constraints aren't met.
type ListInvitationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInvitationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInvitationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInvitationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInvitationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInvitationsRequestValidationError) ErrorName() string {
	return "ListInvitationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListInvitationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInvitationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInvitationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInvitationsRequestValidationError{}

// Validate checks the field values on Invitations with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *Invitations) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetInvitations() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvitationsValidationError{
					field:  fmt.Sprintf("Invitations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// InvitationsValidationError is the validation error returned by
// Invitations.Validate if the designated constraints aren't met.
type InvitationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvitationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvitationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvitationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvitationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvitationsValidationError) ErrorName() string { return "InvitationsValidationError" }

// Error satisfies the builtin error interface
func (e InvitationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvitations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvitationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvitationsValidationError{}

// Validate checks the field values on SendInvitationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *SendInvitationRequest) Validate() error {
	if m == nil {
		return nil
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		return SendInvitationRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
	}

	return nil
}

func (m *SendInvitationRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *SendInvitationRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// SendInvitationRequestValidationError is the validation error returned by
// SendInvitationRequest.Validate if the designated constraints aren't met.
type SendInvitationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendInvitationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendInvitationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendInvitationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendInvitationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendInvitationRequestValidationError) ErrorName() string {
	return "SendInvitationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendInvitationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendInvitationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendInvitationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendInvitationRequestValidationError{}

// Validate checks the field values on DeleteInvitationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *DeleteInvitationRequest) Validate() error {
	if m == nil {
		return nil
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		return DeleteInvitationRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
	}

	return nil
}

func (m *DeleteInvitationRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *DeleteInvitationRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// DeleteInvitationRequestValidationError is the validation error returned by
// DeleteInvitationRequest.Validate if the designated constraints aren't met.
type DeleteInvitationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteInvitationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteInvitationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteInvitationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteInvitationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteInvitationRequestValidationError) ErrorName() string {
	return "DeleteInvitationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteInvitationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteInvitationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteInvitationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteInvitationRequestValidationError{}

// Validate checks the field values on UserSessionIdentifiers with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *UserSessionIdentifiers) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUserIds() == nil {
		return UserSessionIdentifiersValidationError{
			field:  "UserIds",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUserIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSessionIdentifiersValidationError{
				field:  "UserIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetSessionId()) > 64 {
		return UserSessionIdentifiersValidationError{
			field:  "SessionId",
			reason: "value length must be at most 64 runes",
		}
	}

	return nil
}

// UserSessionIdentifiersValidationError is the validation error returned by
// UserSessionIdentifiers.Validate if the designated constraints aren't met.
type UserSessionIdentifiersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSessionIdentifiersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSessionIdentifiersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSessionIdentifiersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSessionIdentifiersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSessionIdentifiersValidationError) ErrorName() string {
	return "UserSessionIdentifiersValidationError"
}

// Error satisfies the builtin error interface
func (e UserSessionIdentifiersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSessionIdentifiers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSessionIdentifiersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSessionIdentifiersValidationError{}

// Validate checks the field values on UserSession with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *UserSession) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUserIds() == nil {
		return UserSessionValidationError{
			field:  "UserIds",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUserIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSessionValidationError{
				field:  "UserIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetSessionId()) > 64 {
		return UserSessionValidationError{
			field:  "SessionId",
			reason: "value length must be at most 64 runes",
		}
	}

	if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSessionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSessionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSessionValidationError{
				field:  "ExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SessionSecret

	return nil
}

// UserSessionValidationError is the validation error returned by
// UserSession.Validate if the designated constraints aren't met.
type UserSessionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSessionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSessionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSessionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSessionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSessionValidationError) ErrorName() string { return "UserSessionValidationError" }

// Error satisfies the builtin error interface
func (e UserSessionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSession.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSessionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSessionValidationError{}

// Validate checks the field values on UserSessions with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *UserSessions) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetSessions() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserSessionsValidationError{
					field:  fmt.Sprintf("Sessions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// UserSessionsValidationError is the validation error returned by
// UserSessions.Validate if the designated constraints aren't met.
type UserSessionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSessionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSessionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSessionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSessionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSessionsValidationError) ErrorName() string { return "UserSessionsValidationError" }

// Error satisfies the builtin error interface
func (e UserSessionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSessions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSessionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSessionsValidationError{}

// Validate checks the field values on ListUserSessionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ListUserSessionsRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetUserIds() == nil {
		return ListUserSessionsRequestValidationError{
			field:  "UserIds",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetUserIds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUserSessionsRequestValidationError{
				field:  "UserIds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _ListUserSessionsRequest_Order_InLookup[m.GetOrder()]; !ok {
		return ListUserSessionsRequestValidationError{
			field:  "Order",
			reason: "value must be in list [ created_at -created_at]",
		}
	}

	if m.GetLimit() > 1000 {
		return ListUserSessionsRequestValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 1000",
		}
	}

	// no validation rules for Page

	return nil
}

// ListUserSessionsRequestValidationError is the validation error returned by
// ListUserSessionsRequest.Validate if the designated constraints aren't met.
type ListUserSessionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserSessionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserSessionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserSessionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserSessionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserSessionsRequestValidationError) ErrorName() string {
	return "ListUserSessionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserSessionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserSessionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserSessionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserSessionsRequestValidationError{}

var _ListUserSessionsRequest_Order_InLookup = map[string]struct{}{
	"":            {},
	"created_at":  {},
	"-created_at": {},
}
